## 컴포넌트 스캔
* 설정정보가 없어도 스프링에서 스프링 빈을 자동으로 등록하도록 도와주는 기능
* 의존관계를 자동으로 주입하는 @Autowired 기능도 있음
* 컴포넌트 스캔은 이름 그대로 @Component 애노테이션이 붙은 클래스를 스캔해서 스프링 빈으로 등록한다.
* @Configuration 애너테이션도 안에 @Component 애노테이션이 붙기 때문에 컴포넌트 스캔의 대상이 된다.

## 컴포넌트 스캔과 자동 의존관계 주입
* @ComponentScan은 @Component가 붙은 모든 클래스를 스프링 빈으로 등록한다.
* 이 때, 스프링 빈의 기본 이름은 클래스명을 사용함(맨 앞글자는 소문자)
* 생성자에 @Autowired를 지정하면, 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입한다.
* 이 때 기본 조회 전략은 타입이 같은 빈을 찾아서 조회한다.
* 생성자에 파라미터가 많아도 다 찾아서 자동으로 주입한다.

## 탐색 위치와 기본 스캔 대상
* 모든 클래스를 컴포넌트 스캔하면 시간이 오래걸리므로, 필요한 위치부터 탐색하도록 지정할 수 있다.
* basePackages: 탐색할 패키지의 시작 위치를 지정한다.(해당 패키지를 포함해서 하위 패키지 모두 탐색)
* 여러 시작 위치를 지정할 수도 있다.
* basePackageClasses: 지정한 클래스의 패키지를 탐색 시작 위치로 지정한다.
* 지정하지 않으면 @ComponentScan이 붙은 설정 정보 클래스의 패키지가 시작 위치가 된다.
* * 권장되는 방법은 패키지 위치를 지정하지 않고, 설정 정보 클래스의 위치를 프로젝트 최상단에 두는 것이다.
* * 스프링 부트를 사용하면 대표 시작 정보인 @SpringBootApplication을 이 프로젝트 시작 위치에 두는것이 관례이다.(그리고 이 설정 안에 @ComponentScan이 들어있다.)

## 컴포넌트 스캔 기본 대상
* @Component
* @Controller
* @Service
* @Repository
* @Configuration

## 필터
* includeFilters: 컴포넌트 스캔 대상을 추가로 지정한다.
* excludeFilters: 컴포넌트 스캔 제외 대상을 지정한다.


## 필터 옵션
1. ANNOTATION: 기본값, 어노테이션을 인식해서 동작한다.
2. ASSIGNABLE_TYPE: 지정한 타입과 자식 타입을 인식해서 동작한다.
3. ASPECTJ: AspectJ 패턴 사용
4. REGEX: 정규 표현식
5. CUSTOM: TypeFilter라는 인터페이스를 구현해서 처리

## 중복 등록과 충돌
### 자동 빈 등록 vs 자동 빈 등록
* 컴포넌트 스캔에 의해 자동으로 스프링 빈이 등록되는데, 그 이름이 같은 경우 오류 발생

### 수동 빈 등록 vs 자동 빈 등록
* 최근에는 수동 빈 등록과 자동 빈 등록이 충돌나면 오류가 발생하도록 기본값 세팅